# <center>反射</center>
###### Tips:反射反射，程序员的快乐，反射是无处不在的，因为太重要了，一些封装框架、系统开发、MVC、IOC、ORM等等都用到它。
[^1]: 反射、反编译工具、高级语言到计算机语言的历程  

一、[什么是反射、反编译](#jump1)    
二、[反射创建对象](#jump2)  
三、[反射+工厂+配置文件断开对细节的依赖](#jump3)  
四、[反射黑科技](#jump4)  
五、[反射调用方法](#jump5)  
六、[反射多种应用场景](#jump6)  
七、[反射的局限、性能问题](#jump7)  
八、[反射操作属性字段](#jump8)  
九、[反射 + ADO.NET实现数据库访问层](#jump9)  
十、[反射的Emit技术](#jump10)

---
## <span id="jump1">一、什么是反射、反编译</span>
### 反射、反编译工具、高级语言到计算机语言的历程  
#### <font color="red"> C#高级语言 --> 编译器（编译） --> DLL/EXE(metadata、IL) --> CLR/JIT --> 机器码（0101）</font>
1. <font color="red">**exe/dll**</font> --> **matedata(元数据)** --> **元数据** ：就是一个 **数据清单** ，描述了当前这个程序集里面包含了哪些元素成员  
2. <font color="red">**IL**</font> --> **中间语言**：也是一个**标准的面向对象语言**。  
3. <font color="red">**ILSpy**</font> --> **反编译工具**，可以呈现 dll/exe 源码的反编译工具。  
4. <font color="red">**反射**</font> --> 就是微软提供的<font color="red">**Reflection**</font>命名空间的**帮助类库**，可以**解析并使用 .DLL/.EXE 结尾文件的 matedata 元数据**；
---
### <span id="jump2"> 二、反射创建对象</span>
#### 传统方式创建对象
>```CSharp
> //1. 添加引用；2. 创建对象；3. 调方法。
> IDBHelper helper = new SqlServerHelper();
> helper.Query();
>```

#### 反射方式创建对象  
>```csharp
>   //1.动态加载dll文件
>   //在当前执行目录下读取,带上DLL的后缀，三种方法中效率最高。
>   Assembly assembly = Assembly.LoadFrom("Business.DB.SqlServer.dll");
>   
>   //有多个重载版本，首先它会去全局程序集缓存查找，然后到应用程序的根目录查找，最后会到应用程序的私有路径查找。
>   //Assembly assembly2= Assembly.Load();
>   
>   //全地址的绝对路径，带后缀
>   //Assembly assembly3= Assembly.LoadFile("E:\\Work\\MyReflection\\bin\\Debug\\net8.0\\Business.DB.SqlServer.dll");
>
>   //2. 获取类型  
>   Type type = assembly.GetType("Business.DB.SqlServer.SqlServerHelper");  //写入程序集类型的全名称
>   foreach (var type in assembly.GetTypes()) { //获取程序集中定义的所有类型。
>       Console.WriteLine($"Type.Name={type.FullName}");  
>
>       foreach (var item in type.GetMethods()) {
>           Console.WriteLine($"method.Name={item.Name}");
>       }
>       foreach (var item in type.GetProPerties()) {
>           Console.WriteLine($"prop.Name={item.Name}");
>       }
>   }
>
>   //3. 使用反射创建对象  
>   // C#是强类型语言，在编译时决定了类型；左边是 object 类型，编译器就认为是 object 类型；实际运行时，是SqlServerHelper；
>   // object? oInstance = Activator.CreateInstance(type); //需要转换，否则用不了程序集里的内容
>   // dynamic oInstance = Activator.CreateInstance(type); //绕过编译器检查，没约束，可随便写，没提示，容易出错
>
>   // 通过反射创建对象得到的结果是object，类型需要类型转换
>   IDBHelper dbHelper = Activator.CreateInstance(type) as IDBHelper;  
>   
>   //4.调用方法    
>   dbHelper.Query();
>```
---
### <span id="jump3"> 三、反射 + 工厂+ 配置文件，断开对细节的依赖</span>
**<font color="red">反射+配置文件+简单工厂</font>**可以完全断开**对细节的依赖**，--程序的可配置化、可扩展化，对配置文件的修改无需停止项目
>```csharp
> //1. 简单工厂 + 配置文件 ；2.调方法。
> IDBHelper dbHelper = SimpleFactory.CreateInstance();
> dbHelper.Query();
>
>public class SimpleFactory {
>    /// <summary>
>    /// 提供一个返回 IDBHelper
>    /// </summary>
>    /// <returns></returns>
>    public static IDBHelper CreateInstance() {
>        string strReflecNames = CustomConfigManager.GetConfig("ReflctionConfig).Split(',');
>
>        Assembly assembly = Assembly.LoadFrom(strReflecNames[0]);   //传递DLL名称加载DLL
>        Type type = assembly.GetType(strReflecNames[1]);        //传递类型名称获取类型
>        return Activator.CreateInstance(type) as IDBHelper;         //创建实体并返回 
>    }
>}
>
>public static class CustomConfigmanager {
>    //Core 读取配置文件：appsettings
>    //1.Microsoft.Extensions.Configuration;
>    //2.Microsoft.Extensions.Configuration.JSon;
>    public static string GetConfig(string key) {
>        //默认读取 当前运行目录
>        var builder = new ConfigurationBuilder().AddJsonFile("appsettings.json");
>        IConfigurationRoot configuration = builder.Build();
>        return configuration.GetSection(key).Value;
>    }
>}
> //配置文件的内容：dll名称,类型名称；"ReflctionConfig":"Builess.DB.SqlServer.dll,Business.DB.SqlServer.SqlServerHelper"
>```
---
### <span id="jump4"> 四、反射黑科技</span>
- 破坏单例：普通的 <font color="red">new</font> 就是去调用它的构造函数，来创建实例
>```csharp
> //正常情况，无法调用。只能通过它提供的方法获取它的实例
> //Singleton singleton1 = new Singleton()
> private static Singleton sineleton = Singleton.GetSingleton();
>
> /// 单例模式：保证在整个进程中，只有一个实例
> public sealed class Singleton {
> 
>   /// 私有化构造函数-->从类的外部是调用不了的
>   private Singleton() => Console.WriteLine("Singleton被构造");
>
>   // 这里的 静态构造函数 或者  静态字段 选一个使用。
>   //private static Singleton _Singleton?;
>
>   /// 静态构造函数，由CLR在类型第一次被使用前调用，且只调用一次。
>   //static Singleton() => _Singleton = new Singleton();
>
>   /// 静态字段，由CLR在类型第一次被使用前初始化，且只初始化一次。
>   private static Singleton _Singleton = new Singleton();
>
>   public static Singleton GetInstance() => return _Singleton;
> }
>
> // Singleton singleton = new Singleton()
> Singleton singleton2 = Singleton.GetInstance();
>
> // 黑科技：突破了访问修饰符的权限；反射可以突破一切权限，私有化成员属性，方法都可以调用。
> Assembly assembly =  Assembly.LoadForm("Builess.DB.SqlServer.dll")
> Type type = assembly.GetType("Business.DB.SqlServer.Singleton");
> //通过反射创建对象得到的结果是object类型
> //object oInstance = Activator.CreateInstance(type); //错误，提示没参数构造函数
> object oInstance = Activator.CreateInstance(type,true);//居然允许调用私有构造函数
>
>``` 
---
### <span id="jump5"> 五、反射调用方法</span>

---
### <span id="jump6"> 六、反射多种应用场景</span>

---
### <span id="jump7"> 七、反射的局限、性能问题)</span>

---
### <span id="jump8"> 八、反射操作属性字段</span>

---
### <span id="jump9"> 九、反射 + ADO.NET 实现数据库访问层</span>

---
### <span id="jump10"> 十、反射的Emit技术</span>


---