# <center>反射</center>
#### Tips：反射反射，程序员的快乐，反射是无处不在的，因为太重要了，一些封装框架、系统开发、MVC、IOC、ORM等等都用到它。
一、[什么是反射、反编译](#jump1)    
二、[反射创建对象](#jump2)  
三、[反射+工厂+配置文件断开对细节的依赖](#jump3)  
四、[反射黑科技](#jump4)  
五、[反射调用方法](#jump5)  
六、[反射多种应用场景](#jump6)  
七、[反射的局限、性能问题](#jump7)  
八、[反射操作属性字段](#jump8)  
九、[反射 + ADO.NET实现数据库访问层](#jump9)  
十、[反射的Emit技术](#jump10)
---
## <span id="jump1"> 一、什么是<font color="red">反射、反编译</font></span>
### 反射、反编译工具、高级语言到计算机语言的历程
#### <font color="red"> C#高级语言 --> 编译器 --> DLL/EXE(metadata、IL) --> CLR/JIT --> 机器码（0101）</font>
1. <font color="red">**EXE/DLL-->matedata(元数据)**</font>  
    **元数据**：就是一个 <font color="red"> **数据清单** </font> ，描述了当前这个程序集里面包含了哪些元素成员；  
2. <font color="red">**IL**</font> --> **中间语言** ：也是一个<font color="red">**标准的面向对象语言**</font>；  
3. <font color="red">**ILSpy**</font> --> **反编译工具**，可以呈现 dll/exe 源码的反编译工具；  
4. <font color="red">**反射**</font> --> 微软提供的<font color="red">**Reflection**</font>命名空间的<font color="red">**帮助类库**</font>，可以<font color="red">**解析并使用 .DLL/.EXE 结尾文件的 matedata 元数据**；</font>
---
## <span id="jump2"> 二、<font color="red">反射创建对象</font></span>
### <font color="red">传统方式</font>创建对象
>```CSharp
> //1. 添加引用；2. 创建对象；3. 调方法。
> IDBHelper helper = new SqlServerHelper();
> helper.Query();
>```
### <font color="red">反射方式</font>创建对象
>```csharp
> Assembly assembly = Assembly.LoadFrom("Business.DB.SqlServer.dll");   //1. 动态加载dll文件
> Type type = assembly.GetType("Business.DB.SqlServer.SqlServerHelper");//2. 获取类型
> IDBHelper dbHelper = Activator.CreateInstance(type) as IDBHelper;     //3. 反射创建对象
> dbHelper.Query();     //4. 调用方法
>
> /** 详细说明
>  * 
>  *  动态加载 DLL 三种方式：
>  *  1.LoadFrom：使用起来最简单，在当前执行目录下读取，带上DLL的后缀，平常用的最多
>  *    Assembly.LoadFrom("Business.DB.SqlServer.dll");
>  *
>  *  2.LoadFile：使用起来也简单，唯一要注意的是，必须写完整的程序集路径，文件名，扩展名
>  *    Assembly.LoadFile("E:\\Work\\MyReflection\\bin\\Business.DB.SqlServer.dll");
>  *
>  *  3.Load：使用起来麻烦点，可以接受的方法 Assembly.Load(File.ReadAllBytes())
>  *    必须包含 后缀名 的 程序集名称 或者包含 完整路径、包含 后缀名 的 程序集名称
>  *    Assembly.Load(File.ReadAllBytes("Business.DB.SqlServer.dll（包含后缀名的程序集名称）"));
>  *    Assembly.Load(File.ReadAllBytes("E:\\Work\\MyReflection\\bin\\Business.DB.SqlServer.dll"));
>  *  
>  *    Type type = assembly.GetType("Business.DB.SqlServer.SqlServerHelper"); // 获取类型
>  *    foreach (var type in assembly.GetTypes()) {     // 获取程序集中定义的所有类型
>  *      Console.WriteLine($"Type.Name={type.FullName}");
>  *      foreach (var item in type.GetMethods()) {     // 获取类型中所有方法
>  *         Console.WriteLine($"method.Name={item.Name}");
>  *      }
>  *      foreach (var item in type.GetProPerties()) {  // 获取此类型中所有属性
>  *         Console.WriteLine($"prop.Name={item.Name}");
>  *      }
>  *    }
>  *
>  *  使用反射创建对象 C# 是强类型语言，在编译时决定了类型；左边是 object 类型，编译器就认为是 object 类型；实际运行是SqlServerHelper；
>  *  object? oInstance = Activator.CreateInstance(type);  //需要转换，否则用不了程序集里的内容
>  *  dynamic dyInstance = Activator.CreateInstance(type); //绕过编译器检查，没约束，没提示，容易出错
>  *
>  *  //通过反射创建对象得到的结果是object，类型需要类型转换
>  *  IDBHelper dbHelper = Activator.CreateInstance(type) as IDBHelper;  
>  *
>  *  //调用方法
>  *  dyInstance.Query();
>  *  dbHelper.Query();
>  */
>```
---
## <span id="jump3"> 三、反射 + 工厂+ 配置文件，<font color="red">断开对细节的依赖</font></span>
#### Tips：<font color="red">反射+配置文件+简单工厂</font>可以完全断开对细节的依赖，程序的可配置化、可扩展化，对配置文件的修改无需停止项目
>```csharp
> //1. 简单工厂 + 配置文件 ；2.调方法。
> IDBHelper dbHelper = SimpleFactory.CreateInstance();
> dbHelper.Query();
>
>public class SimpleFactory {
>   public static IDBHelper CreateInstance() { // 提供一个返回 IDBHelper
>       string strReflecNames = CustomConfigManager.GetConfig("ReflctionConfig").Split(',');
>       Assembly assembly = Assembly.LoadFrom(strReflecNames[0]);   //传递DLL名称加载DLL
>       Type type = assembly.GetType(strReflecNames[1]);            //传递类型名称获取类型
>       return Activator.CreateInstance(type) as IDBHelper;         //创建实体并返回
>   }
>}
>
>using Microsoft.Extensions.Configuration;
>using Microsoft.Extensions.Configuration.JSon;
>public static class CustomConfigmanager {
>    //Core 读取配置文件：appsettings，配置文件的内容：dll名称,类型名称；
>    public static string GetConfig(string key) {
>        //默认读取 当前运行目录，"ReflctionConfig":"Builess.DB.SqlServer.dll,Business.DB.SqlServer.SqlServerHelper"
>        var builder = new ConfigurationBuilder().AddJsonFile("appsettings.json");
>        IConfigurationRoot configuration = builder.Build();
>        return configuration.GetSection(key).Value;
>    }
>}
>```
---
## <span id="jump4"> 四、反射<font color="red">黑科技</font></span>
- **<font color="red">破坏单例</font>**：普通的 <font color="red">new</font> 就是去调用它的构造函数，用来创建实例。
- **<font color="red">黑科技</font>**：突破了访问修饰符的权限；反射可以突破一切权限，私有化成员属性，方法都可以调用。
- **反射做到了普通方式做不到的事儿**。
>```csharp
> public sealed class Singleton { // 单例模式：保证在整个进程中，只有一个实例
>   // 私有化构造函数-->从类的外部是调用不了的
>   private Singleton() => Console.WriteLine("Singleton被构造");
>
>   // 这里的 静态构造函数 或者  静态字段 选一个使用。
>   //private static Singleton _Singleton?;
>
>   // 静态构造函数，由CLR在类型第一次被使用前调用，且只调用一次。
>   //static Singleton() => _Singleton = new Singleton();
>
>   // 静态字段，由CLR在类型第一次被使用前初始化，且只初始化一次。
>   private static Singleton _Singleton = new Singleton();
>   public static Singleton GetInstance() => return _Singleton;
> }
>
> //Singleton singleton1 = new Singleton(); //正常情况，无法调用。只能通过它提供的方法获取它的实例
> private static Singleton sineleton = Singleton.GetSingleton();
>
> // 黑科技：突破了访问修饰符的权限；反射可以突破一切权限，私有化成员属性，方法都可以调用。
> Assembly assembly =  Assembly.LoadForm("Builess.DB.SqlServer.dll")
> Type type = assembly.GetType("Business.DB.SqlServer.Singleton");
>
> //通过反射创建对象得到的结果是object类型
> //这句会提示错误，没有无参数构造函数
> //object oInstance = Activator.CreateInstance(type); 
>
> //突破权限：居然允许调用私有构造函数
> object oInstance = Activator.CreateInstance(type,true);
>``` 
---
## <span id="jump5"> 五、反射<font color="red">调用方法</font></span>
### 反射<font color="red">创建实例</font>的方式
>``` csharp
> Assembly assembly = Assembly.LoadFrom("Builess.DB.SqlServer.dll");      //传递DLL名称加载DLL
> Type type = assembly.GetType("Business.DB.SqlServer.SqlServerHelper");  //传递类型名称获取类型
> 
> //方式1：【强制转换】
> IDBHelper dbHelper = Activator.CreateInstance(type) as IDBHelper ;
> dbHelper.query();
>
> //方式2：【Dynamic】：绕过编译器检查，没约束，没提示，错了也不知道，运行的时候才会报错；
> dynamic oInstance = Activator.CreateInstance(type);
> 
> //方式3：【MethodInfo】的【Invoke】
> MethodInfo mtehod = type.GetMethod("Query);
> mtehod.Invoke(oInstance, new object[0]);
>```
### 反射创建对象的时候，<font color="red">指定具体构造函数</font>
#### Tips：传入和参数列表匹配相同类型的数据即可
>```csharp
> object? oInstance =  Activator.CreateInstance(type);//无参数构造函数
> Activator.CreateInstance(type, new object[]{"Summary."});//一个参数string类型
> Activator.CreateInstance(type, new object[]{123, "Summary."});//两个参数 int,string 类型
>```
### 反射<font color="red">调用方法</font>
>```csharp 
> Assembly assembly = Assembly.LoadFrom("Builess.DB.SqlServer.dll");
> Type type = assembly.GetType("Business.DB.SqlServer.SqlServerHelper");
> object? oInstance =  Activator.CreateInstance(type);
>
> //无参数方法--> Query ,无参数可以传 null ,也可以传 new object[0];
> MethodInfo query = type.GetMethod("Query);
> query.Invoke(oInstance, new object[0]);
>
> //一个参数方法
> MethodInfo query2 = type.GetMethod("Query2");
> query2.Invoke(oInstance, new object[] { 3456 });
> 
> //反射调用重载方法【重载方法：方法的名称一样，返回值一样，唯独方法的参数列表不一样】
> //所以需要进一步精确查找是哪个方法，指定参数列表的每一个类型
> MethodInfo query3 = type.GetMethod("Query3", new Type[] { typeof(int), typeof(string)});
> query3.Invoke(oInstance, new object[] { 3456, "打武松的小老虎" });
>
> // 反射调用私有方法
> MethodInfo query4 = type.GetMenthod("Query4", BindingFlags.Instance | BindingFlags.NonPublic);
> query4.Invoke(oInstance , new object[]{"判官"});
>
> // 反射调用静态方法，静态类不需要类的实例也可以执行，可传可不传
> MethodInfo query5 = type.GetMethod("Show5");
> query5.Invoke(null, new object[] {"华尔茨"}); 
>
> // 一次获取多个方法，循环执行
> MethodInfo[] methods = type.GetMenthods();
>```
### 反射调用<font color="red">泛型方法、泛型类</font>
#### 【泛型方法】延迟声明，声明时不确定类型，只给一个占位符，在使用的时候确定类型
>```csharp
> Assembly assembly = Assembly.LoadFrom("Builess.DB.SqlServer.dll");                //传递DLL名称加载DLL
> Type typeGenericMethod = assembly.GetType("Business.DB.SqlServer.GenericMethod"); //传递类型名称获取类型
> object? oInstance =  Activator.CreateInstance(typeGenericMethod);
>
> // 【泛型方法】
> MethodInfo show = typeGenericMethod.GetMethod("Show");// 确定具体方法类型
> MethodInfo show1 = show.MakeGenericMethod(new Type[]{ typeof(int), typeof(string), typeof(DateTime)});
> show1.Invoke(oInstance, new object[] { 234, "Daisy", DateTime.Now });
>
>
> // 【泛型类】--> 获取泛型类的类型，需要在类的名称后标记上【占位符、数量】表示有多少个类型参数
> Type typeGenericClass = accembly.GetType("Business.DB.SqlServer.GenericClass`3");
>
> // 需要指定泛型类的【具体类型】
> Type typeMakeGeneric = typeGenericClass.MakeGenericType(new Type[]{ typeof(int), typeof(string), typeof(Datetime)});
>
> // 使用泛型指定类型来创建实例
> object oInstance = Activator.CreateInstance(typeMakeGeneric);
> 
> // 这里的【泛型方法】完全依赖于【泛型类】，执行的时候严格按照参数列表执行。
> MethodInfo methodInfo = typeMakeGeneric.GetMethod("Show2");
> methodInfo.Invoke(oInstance, new object[]{ 345, "Daisy", Datetime.Now});
>
> //【泛型类-->泛型方法】泛型类的参数传递给泛型方法的第一个参数。
> Type typeGenericClass2 = accembly.GetType("Business.DB.SqlServer.GenericDouble`1");
> Type typeMakeGeneric = typeGenericClass2.MakeGenericType(new Type[]{typeof(int) });
>
> object oInstance = Activator.CreateInstance(typeMakeGeneric);
> MethodInfo methodInfo2 = typeMakeGeneric.GetMethod("Show");
> MethodInfo methodInfo3 = methodInfo2.MakeGenericMethod(new Type[]{ typeof(string), typeof(DateTime)});
> methodInfo3.Invoke(oInstance, new object[]{ 142, "Vance", Datetime.Now });
---
## <span id="jump6"> 六、反射多种应用场景</span>
### 1.在MVC中有应用，请示的路径包含了控制器和方法，通过反射获取控制器的类型，创建实例，根据路径中方法的名称确定要执行的具体的 Action 方法。
### 2.简单工厂其实是一个 IOC 容器的雏形
### 3.反射在 ORM 框架中的使用
#### 开发中，反射无处不在（基础功能开发、插件式开发、框架搭建、封装组件）。
#### 反射反射，程序员的快乐，有了反射基本无所不能
---
## <span id="jump7"> 七、反射的局限、性能问题</span>
### 反射会有性能损失，但是只要程序员的代码足够优秀，性能是可以得到优化的。
### 反射请放心使用，损失的一点点性能完全是可以接受的，它可以给我们带来更强大的功能。
---
## <span id="jump8"> 八、反射操作属性字段</span>
>```csharp
>public class People {
>   //属性    
>   public int Id {get;set;}    
>   public string Name {get;set;}
>   public int Age {get;set;}
>   //字段
>   public string Description;
>}
>
>People people = new People();
>
>//常规方案给属性字段赋值
>people.Id = 123;
>people.Name = "VanceLi";
>people.Age = 28;
>people.Description = "一枚程序员"
>
>//常规方案取属性字段的值
>Console.WriteLine("$people.Id={people.Id}");
>Console.WriteLine("$people.Name={people.Name}");
>Console.WriteLine("$people.Age={people.Age}");
>Console.WriteLine("$people.Description={people.Description}");
>
>//增加一个字段或者是增加一个属性呢？取值还是赋值，都需要修改代码
>//反射操作，至少取值代码完全不用动
>
>
>Type type = typeof(People);
>object oInstance = Activator.CreateInstance(type);
>//反射方案给属性字段赋值
>foreach (PropertyInfo prop in type.GetProperties()){
>   if (prop.Name == "Id"){
>       prop.SetValue(oInstance,123);
>   } else if(prop.Name == "Name"){
>       prop.SetValue(oInstance,"Daisy");
>   } else if(prop.Name == "Age"){
>       prop.SetValue(oInstance,18);
>   }
>   Console.WriteLine(prop.Name);
>}
>foreach(FieldInfo field in type.GetFields()){
>   if(field.Name == "Description"){
>       field.SetValue(oInstance,"惊为天人");
>   }
>}
>
>//反射方案取属性字段的值
>foreach (PropertyInfo prop in type.GetProperties()){
>   object oValue = prop.GetValue(oInstance);
>   Console.WriteLine($"people.{prop.Name}={oValue}");
>}
>foreach (FieldInfo field in type.GetFields()){
>   object oValue = field .GetValue(oInstance);
>   Console.WriteLine($"prople.{field.Name}={oValue}");
>}    
>```
---
## <span id="jump9"> 九、反射 + ADO.NET 实现数据库访问层</span>

---
## <span id="jump10"> 十、反射的Emit技术</span>


---