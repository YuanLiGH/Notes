### 一、泛型的引入
> #### <font color='red'>什么是泛型：不确定的类型。</font>
> **Tips:是根据方法的 <font color='red'>*重载*</font> 衍生而来。**     
> 
> 有时写方法会，因为要潢传入不同的参数类型，只能重复写相同的方法体。写多了就会想一个问题?    
> 
>  **能不能把他们合并一下？使一个方法可以满足多种类型的传入？**  
>  
> ##### <font color='red'>概念：任何子类出现的地方都可以用父类替换</font>
> 
> 就出现了 **<font color='red'>ShowObject</font>方法** ：  但有了 **<font color='red'>数据安全</font>** 和 **<font color='red'>性能</font>** 两个问题。  
> 
> **数据安全**：object 类型作为参数，所有类型都可以传入；在方法的内部业务处理，可能会因为一些不适合的类型传入，导致一些问题；  
> 
> ShowObject特点：**<font color='red'>允许你传入，可能会报错。</font>**  
> 
> **最好的情况：如果方法内部会出错，就应该不让你传入；如果能传入，就要保证一定没问题；** 泛型来解决 --.Net Framework 1.0 时代
> ```Csharp
>   private static void ShowInt(int iParameter){ }
>   
>   private static void ShowString(int strParameter){ }  
>
>   private static void ShowObject(Object oParameter) {
>       Console.WriteLine($"This is {typeof(CommonMenthod).Name},parameter={oParameter.GetType().Name},type={oParameter}");
>       // 以上业务太简单，实际使用时不够。如果想用People呢？
>       // c#是强类型语言，编译时决定了类型;
>       // 编译器识别的 oParameter 是 object ，而 object 里没有 Id,Name属性，所以访问不了。
>       // Console.WriteLine($"People.Id={oParameter.Id}");
>       // Console.WriteLine($"People.Name={oParameter.Name}");
>   
>       //一定要访问怎么办？ 类型转换,可能会因为一些不适合的类型传入，导致出问题，这就是数据安全。
>       People people = (People)oParameter;
>       Console.WriteLine($"People.Id={people.Id}");
>       Console.WriteLine($"People.Name={people.Name}");
>   }
> ```

### 二、泛型的设计思想
> **计算机执行的都是机器码；** 代码在底层执行的时候 ---必须要明确是什么类型的；  
> 
> **定义时：标识泛型，带有尖括号<>，尖括号里面---有占位符“T”。<font color='red'>占位符可以是A，B，C，abc,只要不是关键字都可</font>**  
> 
> **占位符“T”是什么？ T是类型---称之为:<font color='red'>类型参数</font>;** 
> 
> T具体是什么类型？ 不知道，只有在调用的时候才确定类型；
> 
> **这个设计思想称之为<font color='red'>延迟声明</font>；**
> 
> #### <font color='red'>延迟声明：声明时不确定类型，调用时确定类型；</font>

### 三、泛型的核心特点+原理--在底层如何支持  
> #### <font color='red'>泛型不是语法糖，而是由框架的升级来支持的；</font>
> .Net Framework 2.0 时代；泛型升级，在编译后:变成 一个带有`符号[位数]； 需要哪些环节支持？
> 1. 升级---**编译器**      编译器必须要支持尖括号``
> 2. 升级---**运行时环境**  运行时环境也需要支持泛型的符号
> 3. 升级---**语法**        支持的语法也需要升级
> ```Csharp
>   Console.WriteLine(typeof(List<>));
>   Console.WriteLine(typeof(Dictionary<,>));
> ```

### 四、泛型的声明和多种应用
> ####  <font color='red'>特点：为每一个不同类型生成一个唯一的副本；</font>   
> 性能很高，可以说要又叫马儿跑，又叫马儿不吃草。真香~~
> 1. **泛型方法：** 方法名后面带有尖括号和类型参数 ---一个方法满足不同类型的需求；
>```Csharp
>   public static void ShowGeneric<T>(T oParameter){}
>
>   ShowGeneric<int>(11);
>   ShowGeneric<string>("asdf");
>   ShowGeneric<DataTime>(DateTime.Now);
>   ShowGeneric<object>(null);
> ```
> 2. **泛型类：** 类名后面带有尖括号和类型参数 ---一个类满足不同类型的需求；
> ```Csharp
>   public class GenericClass<T>{};
>
>   GenericClass<String> sGeneric = new GenericClass<string>();
>   GenericClass<DataTime> dGeneric = new GenericClass<DateTime>();
> ```
> 3. **泛型接口：** 接口后面带有尖括号和类型参数---一个接口满足不同类型的需求；
> ```CSharp
> public interface GenericInterface<T>{}
> public class MyClass<T>:GenericInterface<T>{}
>
> GenericIntterface<int> intInterface = new MyClass<int>();
> GenericInterface<string> strInterface = new MyClass<string>();
> GenericInterface<DateTime> dtInterface = new MyClass<DateTime>();
> ```
> 4. **定义委托---泛型委托：** 委托名称后面带有尖括号和类型参数---一个委托满足不同类型的需求
>```CSharp  
> public delegate void CustomAction<T>(T obj);
>
> CustomAction<int> customAction1 =  s =>{ };
> CustomAction<string> customAction2 = s=>{ };
> CustomAction<DateTime> customAction3 = s=>{ };
>```

### 五、泛型约束，泛型缓存
> **特点：有了约束--虽然限制了局部传入参数，但是保证了安全；要么不允许进来，进来了就不允许报错。**
> #### <font color='red'>基类约束：泛型的类型参数，必须是某个基类或基类的子类；</font>
> 有了约束就有了权利
>``` CSharp  
>    ///基类约束
>   public static void ShowGeneric<T>(T t) where T : People {  
>        Console.WriteLine($"People.Id={t.Id}");
>        Console.WriteLine($"People.Name={t.Name}");
>   }
>```
> #### <font color='red'>接口约束：类型参数必须实现这个接口，就可以把参数当成接口使用</font>
> ```CSharp
>   ///接口约束  
>   public static void ShowGeneric<T>(T t) where T: IWork {
>       t.Work();
>   }
> ```
> #### <font color='red'>无参数构造函数约束：传入参数，必须包含一个无参数构造函数，就可以直接new T 执行无参数构造函数</font>
> ```CSharp
>   public static void ShowGeneric<T>(T t) where T : new() {
>       T tt = new T();
>   }
> ```
> #### <font color='red'>值类型约束/结构类型约束：必须要传入结构类型</font>
> ```CSharp
>   public static void ShowGeneric<T>(T t) where T : struct { }
> ```
> #### <font color='red'>引用类型约束：必须要传入引用类型</font>
> ```CSharp
>   public static void ShowGeneric<T>(T t) where T : class { }
> ```
> #### <font color='red'>枚举约束：必须要传入枚举/font>
> ```CSharp
>   public static void ShowGeneric<T>(T t) where T : Enum { }
>
>   public enum ColorType { Red, Green, Blue }
>   GenericConstraint.ShowGeneric(ColorType.Green);
> ```
> #### <font color="red">普通缓存</font>---字典缓存：静态属性常驻内存 
> ```CSharp  
>   public class DictionaryCache {
>       private static Dictionary<Type,string> _TypeTimeDictionary = null;
>   
>       static DictionaryCache() {
>           Console.WriteLine("This is DictionaryCache 静态构造函数");
>           _TypeTimeDictionary = new Dictionary<Type, string>();
>       }
>   
>       public static string GetCache<T>() {
>           Type type = typeof(Type);
>           if(!_TypeTimeDictionary.ContainsKey(type)){
>               _TypeTimeDictionary[type] = $"{typeof(T).FullName}_{DateTime.Now.ToString('yyyyMMddHHmmss.fff')}";
>           }
>           return _TypeTimeDictionary[type];
>       }
>   }
>   public class GenericCacheTest {
>       public static void Show() {
>           font(int i = 0; i < 5; i++) {
>               Console.WriteLine(DictionaryCache.GetCache<int>());
>               Thread.Sleep(10);
>               Console.WriteLine(DictionaryCache.GetCache<long>());
>               Thread.Sleep(10);
>               Console.WriteLine(DictionaryCache.GetCache<DateTime>());
>               Thread.Sleep(10);
>               Console.WriteLine(DictionaryCache.GetCache<string>());
>               Thread.Sleep(10);
>               Console.WriteLine(DictionaryCache.GetCache<DictionaryCache>());
>           }
>       }
>   }
> ```
> #### <font color='red'>泛型缓存</font> ---为每个类型生成一个不同的副本，效率高。  
> 
> **在使用泛型缓存的时候，其实是去调用普通类型， 效率远远高于普通缓存**
> ```CSharp
>   public class GenericCache<T> {
>       private static string _TypeTime = "";
>
>       static GenericCache() {
>           Concole.WriteLine("This is GenericCache 静态构造函数");
>           _TypeTime = $"{typeof(T).FullName}_{DateTime.Now.ToString("yyyyMMddHHmmss")}";
>       } 
>   }
>
>   public static string GetCache(){ 
>       return _TypeTime;    
>   }
>
>   public static void Show() {
>       for (int i = 0; i < 5; i++) {
>           Console.WriteLine(GenericCache<int>.GetCache());
>           Thread.Sleep(10);
>           Console.WriteLine(GenericCache<long>.GetCache());
>           Thread.Sleep(10);
>           Console.WriteLine(GenericCache<DateTime>.GetCache());
>           Thread.Sleep(10);
>           Console.WriteLine(GenericCache<string>.GetCache());
>           Thread.Sleep(10);
>           Console.WriteLine(GenericCache<GenericCacheTest>.GetCache());
>           Thread.Sleep(10);  
>       }
> }
> ```

### 六、协变，逆变