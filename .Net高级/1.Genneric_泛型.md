# 泛型的引入、泛型的声明
> #### 泛型：不确定的类型。是从方法的 *重载* 衍生而来。相同的方法名，不同的参数类型，要做的事儿都是一样的，然后就有一个问题：*能不能把他们合并一下？一个方法满足多种类型的传入* ShowObject出现了，引用类型，任何子类出现的地方都可以用父类替换，但是有 *数据安全* 和 *性能* 两个问题，不是最好的方案。
> ```C#  
>   /// 值类型
>   private static void ShowInt(int iParameter){  
>    //do nothing
>   }
>
>   private static void ShowString(int strParameter){  
>    //do nothing
>   }  
>
>   private static void ShowObject(Object oParameter){
>      //do nothing    
>   }
> ```

> #### 泛型方法：一个方法可以传入不同的类型，满足不同类型的需求；性能很高，又叫马儿跑，又叫马儿不吃草真香！
> ``` C#
>   public static void ShowGeneric<T>(T oParameter){
>       //do nothing
>   }
>
>   ShowGeneric<int>(11);
>   ShowGeneric<string>("asdf");
>   ShowGeneric<DataTime>(DateTime.Now);
>   ShowGeneric<object>(null);
> ```

# 泛型的核心特点+原理，设计思想
> #### 代码在底层执行的时候 ---必须要明确清楚是什么类型的；计算器执行的都是机器码；
> #### 声明：定义的时候，带有尖括号<>，尖括号里面---有位符T；T是什么？ T是类型---称之为:类型参数; 这个T具体是什么类型？ 不知道~~在调用 的时候 确定类型；
> #### 延迟声明：声明时不确定类型，调用确定类型；
>
>
>
>
>

# 泛型方法，泛型类，泛型接口，泛型委托
# 泛型约束，泛型缓存，协变，逆变